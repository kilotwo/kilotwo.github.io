<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenCV-1]]></title>
    <url>%2F2019%2F04%2F11%2FOpenCV-1%2F</url>
    <content type="text"><![CDATA[图像处理中的概念图像高频部分代表了图像的细节、纹理信息；低频代表了图像的轮廓信息。 低通-》模糊 高通-》锐化 腐蚀和膨胀是针对白色部分（高亮部分）而言的。膨胀就是对图像高亮部分进行“领域扩张”，效果图拥有比原图更大的高亮区域；腐蚀是原图中的高亮区域被蚕食，效果图拥有比原图更小的高亮区域。 开运算：先腐蚀再膨胀，用来消除小物体 闭运算：先膨胀再腐蚀，用于排除小型黑洞 形态学梯度：就是膨胀图与俯视图之差，用于保留物体的边缘轮廓。 顶帽：原图像与开运算图之差，用于分离比邻近点亮一些的斑块。 黑帽：闭运算与原图像之差，用于分离比邻近点暗一些的斑块。 rows:行cols:列 常用的数据结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;opencv2\opencv.hpp&gt; #include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;//常见数据结构使用方法总结int main()&#123; //Mat的用法 Mat m1(2, 2, CV_8UC3, Scalar(0, 0, 255)); //其中的宏的解释：CV_[位数][带符号与否][类型前缀]C[通道数] cout &lt;&lt; m1 &lt;&lt; endl; //或者,利用IplImage指针来初始化,将IplImage*转化为Mat IplImage* image = cvLoadImage(&quot;lena.jpg&quot;); Mat mat = cvarrToMat(image); //Mat转IplImage: IplImage img = IplImage(mat); //或者 Mat m2; m2.create(4, 5, CV_8UC(2)); //点的表示:Point Point p; p.x = 1; //x坐标 p.y = 1; //y坐标 //或者 Point p2(1, 1); //颜色的表示：Scalar(b,g,r);注意不是rgb，注意对应关系 Scalar(1, 1, 1); //尺寸的表示:Size Size(5, 5);// 宽度和高度都是5 //矩形的表示：Rect，成员变量有x,y,width,height Rect r1(0, 0, 100, 60); Rect r2(10, 10, 100, 60); Rect r3 = r1 | r2; //两个矩形求交集 Rect r4 = r1 &amp; r2; //两个矩形求并集 waitKey(0); 访问图片中像素的方式Mat类有若干成员函数可以获取图像的属性。cols表示列，rows表示行，channels()返回图像的通道数，灰度图通道数1，彩色图通道数3。每行的像素值由一下语句得到：1int colNumber = outputImage.cols*outputImage*channels();//列数*通道数=每一行元素个数 （有点三维立体的感觉） 为了简化指针运算，Mat类提供了ptr函数可以得到图像任意行的首地址。ptr是一个模版函数，它返回第i行的首地址：1uchar* data = img.ptr&lt;uchar&gt;(i); //获取第i行地址 12345678910111213141516171819202122#include&lt;opencv2\opencv.hpp&gt; #include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;//使用指针的方式int main()&#123; Mat img = imread(&quot;lol1.jpg&quot;); for (int i = 0; i &lt; img.rows; i++) &#123; uchar* data = img.ptr&lt;uchar&gt;(i); //获取第i行地址 for (int j = 0; j &lt; img.cols; j++) &#123; printf(&quot;%d\n&quot;,data[j]); &#125; &#125; waitKey(0);&#125; 感兴趣区域：ROI在图像处理领域，常常需要设定感兴趣区域（ROI,region of interest）来专注或者简化工作过程，即在图像中选择一个图像区域，这个区域是图像分析关注的重点。而且使用ROI指定想读入的目标，可以减少处理时间，增加精度，带来便利。定义ROI区域两种方法：1.使用表示矩形区域的Rect2.Range指定感兴趣的行或列的范围 基础图像操作创建窗口：namedWindow() void namedWindow(const String&amp; winname, int flags = WINDOW_AUTOSIZE); 因为有时候需要用到窗口的名字，尽管这个时候还没有载入图片，比如我们要在一个窗口上加入一个工具条，我们必须首先知道窗口的名字，这样才知道在哪里加上这个toolbar。 namedWindow还有一个很重要的功能，如果使用默认参数，窗口是无法自由调整的，如果想实现用户自由拉伸窗口，可以这么做：12namedWindow(&quot;srcImage&quot;, WINDOW_NORMAL);// 注意这个宏，使用WINDOW_NORMAL可以允许用户自由伸缩窗口大小 imshow(&quot;srcImage&quot;, srcImage); 输出图像到文件：imwrite()1bool imwrite( const String&amp; filename, InputArray img,const std::vector&amp;params = std::vector()); 创建trackbar以及使用下面的例子利用trakbar打开多个图片。12345678910111213141516171819202122232425262728293031#include&lt;opencv2\opencv.hpp&gt; #include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;#define PIC_MAX_NUM 5int pic_num = 0;void on_track(int,void*)&#123; char file[10]; sprintf(file, &quot;%d.jpg&quot;, pic_num); Mat img = imread(file); if (!img.data) &#123; cout &lt;&lt; &quot;读取图片失败&quot; &lt;&lt; endl; return; &#125; imshow(&quot;展示多幅图片&quot;, img);&#125;int main()&#123; namedWindow(&quot;展示多幅图片&quot;); createTrackbar(&quot;图片编号&quot;, &quot;展示多幅图片&quot;, &amp;pic_num, PIC_MAX_NUM, on_track); on_track(pic_num, NULL); waitKey(0);&#125; 转为灰度图1234567891011121314151617#include&lt;opencv2\opencv.hpp&gt; #include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;int main()&#123; Mat img = imread(&quot;lol1.jpg&quot;); Mat dstImg; cvtColor(img, dstImg,COLOR_BGR2GRAY);//从宏名字就可以知道，是彩色图转换到灰度图 imshow(&quot;灰度图&quot;, dstImg); waitKey(0);&#125; 图像二值化操作两种方法，全局固定阈值二值化和局部自适应阈值二值化 1.全局固定阈值很容易理解，就是对整幅图像都是用一个统一的阈值来进行二值化； 2.局部自适应阈值则是根据像素的邻域块的像素值分布来确定该像素位置上的二值化阈值。1234567891011121314151617181920212223242526272829303132#include&lt;opencv2\opencv.hpp&gt; #include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;int main(int argc, char** argv)&#123; Mat image = imread(&quot;lol1.jpg&quot;, CV_LOAD_IMAGE_GRAYSCALE); //注意了，必须是载入灰度图 if (image.empty()) &#123; cout &lt;&lt; &quot;read image failure&quot; &lt;&lt; endl; return -1; &#125; // 全局二值化 int th = 100; Mat global; threshold(image, global, th, 255, CV_THRESH_BINARY_INV); // 局部二值化 int blockSize = 25; int constValue = 10; Mat local; adaptiveThreshold(image, local, 255, CV_ADAPTIVE_THRESH_MEAN_C, CV_THRESH_BINARY_INV, blockSize, constValue); imshow(&quot;全局二值化&quot;, global); imshow(&quot;局部二值化&quot;, local); waitKey(0); return 0;&#125; Canny边缘检测思路：将原始图像转化为灰度图，用blur函数进行图像模糊以降噪，然后用Canny函数进行边缘检测。需要注意的是，这个函数阈值1和阈值2两者中较小的值用于边缘连接，而较大的值用来控制强边缘的初始端，推荐的高低阈值比在2：1和3：1之间。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;opencv2\opencv.hpp&gt;using namespace cv;using namespace std;int main()&#123; Mat SrcPic = imread(&quot;1.jpg&quot;); imshow(&quot;Src Pic&quot;, SrcPic); Mat DstPic, edge, grayImage; //创建与src同类型和同大小的矩阵 DstPic.create(SrcPic.size(), SrcPic.type()); //将原始图转化为灰度图 cvtColor(SrcPic, grayImage, COLOR_BGR2GRAY); //先使用3*3内核来降噪 edge为均值滤波后图像，需与原图像大小一样 blur(grayImage, edge, Size(3, 3)); //运行canny算子，最后一个3 是默认算子孔径 Canny(edge, edge, 3, 9, 3); imshow(&quot;边缘提取效果&quot;, edge); waitKey(); return 0;&#125; 直方图均衡化直方图 可以用来反映灰度情况（0-255分布情况），每个等级的频数分布直方图均值化拉伸图像的灰度值范围，使得两头变多（0和255），所以提高了对比度，显然均衡化后的图片对比度变高了，变得更加明亮。123456789101112131415161718192021#include&lt;opencv2\opencv.hpp&gt; #include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;//直方图均衡化int main()&#123; Mat img = imread(&quot;3.jpg&quot;); imshow(&quot;原始图&quot;, img); Mat dst; cvtColor(img, img, CV_RGB2GRAY); imshow(&quot;灰度图&quot;, img); equalizeHist(img, dst); imshow(&quot;直方图均衡化&quot;, dst); waitKey(0);&#125;]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
